?-use_module(library(clpfd)).
%%
%% Кореново двоично дърво - nil или tree(n, _, _)
%%

%%
%% височина(T,N) - двоичното дърво T има височина N
%% 
%% Условие - известна е скелета на дървото T
%% 
дърво_височина(nil, 0).
дърво_височина(tree(_,L,R),N) :- N #= max(N1,N2)+1, N #> 0, дърво_височина(L,N1), дърво_височина(R,N2).

%%
%% дърво_брой(T,N) - Броят на възлите в двоичното дърво T е N на брой.
%% 
дърво_брой(nil,0).
дърво_брой(tree(_,L,R),N) :- N #= N1+N2+1, N1 #>= 0, N2 #>= 0, дърво_брой(L,N1), дърво_брой(R,N2).



%%
%% дърво_вмък(A, T, T') - подреденото дърво T' се получава от подреденото дърво T като вмъкнем елемента A
%%
%% Условие - елементът A е известен и са известни елементите на T или T'
%% 
дърво_вмък(A, nil, tree(A,nil,nil)).
дърво_вмък(A, tree(B,L,R), tree(B,L1,R)) :- A #=< B, дърво_вмък(A, L, L1).
дърво_вмък(A, tree(B,L,R), tree(B,L,R1)) :- A #> B, дърво_вмък(A, R, R1).



%% дърво_баланс(nil,nil).
%% дърво_баланс(tree(B,tree(A,L,R),C), ) :- дърво_баланс(

%%
%% дърво_много_вмък(L,T,T1) - T1 е подредено дърво, което може да се получи от T, към което се прибавят елемените на списъка L
%%
%% Условие - известни са елементите на списъка L и елементите на T
%% 
дърво_много_вмък([], T, T).
дърво_много_вмък([A|Rest], T, T2) :- дърво_много_вмък(Rest, T, T1), дърво_вмък(A, T1, T2).




%% 
%% равен_брой(T,L) - дървото T и списъка L имат равен брой елементи
%%
%% Условие - известен е скелета на T или дължината на L
%% 
равен_брой(T,L) :- списък_минус_дърво(L,T,[]).

%%
%% списък_минус_дърво(L,T,M) - M = елементите на L, без първите N елемента, където N = брой възли в T.
%% 
списък_минус_дърво(X,nil,X).

списък_минус_дърво([_|X], tree(_,L,R), Y) :-
    списък_минус_дърво(X,L,Z), списък_минус_дърво(Z,R,Y).

%%
%% дърво_списък(T,L) - L представлява елемените на T подредени по схемата ляв-корен-дясно
%%
%% Условие - известна е скелета на дървото T или дължината на списъка L
%% 
дърво_списък(nil,[]).
дърво_списък(tree(B,L,R), X) :- равен_брой(tree(B,L,R),X), конкат(X1, [B|X2], X), дърво_списък(L, X1), дърво_списък(R, X2).

%%
%% дърво_сорт(L,S) - S е пермутацията на L, такава че елемените на S са подредени във възходящ ред
%%
%% Условие - известни са елементите на L
%% 
сорт_дърво(L,S) :- дърво_много_вмък(L,nil,T), дърво_списък(T,S).

%%
%% дърво_макс(T,A) - елементът A е най-големият елемент в подреденото дърво T
%%
%% Условие - Известна е структурата на дървото T
%% 
дърво_макс(tree(X,_,nil),X).
дърво_макс(tree(_,_,R),Y) :- дърво_макс(R,Y).

%%
%% дърво_мин(T,A) - елементът A е най-малкият елемент в подреденото дърво T
%%
%% Условие - Известна е структурата на дървото T
%% 
дърво_мин(tree(X,nil,_),X).
дърво_мин(tree(_,L,_),Y) :- дърво_мин(L,Y).

%%
%% дърво_елем(T,E) - елементът E е връх в подреденото дърво T
%%
%% Условие - скелета на дървото T
%% 
дърво_елем(tree(A,_,_),A).
дърво_елем(tree(A,L,_),B) :- B #< A, дърво_елем(L,B).
дърво_елем(tree(A,_,R),B) :- A #< B, дърво_елем(R,B).
%%
%% Пример:
%%
%% ?- дърво_брой(T,2), дърво_елем(T,1), дърво_елем(T,2).
%% T = tree(1, nil, tree(2, nil, nil)) ;
%% T = tree(2, tree(1, nil, nil), nil) ;
%% false.


%%
%% дърво_подредено(T) - T е дърво с подредба да елементите ляв-корен-десен
%% 
%% Условие - известни са елемените на T
%% 
дърво_подредено(nil).
дърво_подредено(tree(X,L,R)) :- дърво_макс(L,Y), дърво_мин(R,Z), Y =< X, X =< Z.


дърво_измък(A, tree(A,L,nil),L).
дърво_измък(A, tree(A,nil,R),R).
дърво_измък(A, tree(A,tree(B,L1,R1), R), tree(B,L1,R2)) :- дърво_списък(R1,S), дърво_много_вмък(S,R,R2).
дърво_измък(A, tree(B,L,R), tree(B,L1,R)) :- A =< B, дърво_измък(A, L, L1).
дърво_измък(A, tree(B,L,R), tree(B,L,R1)) :- B < A, дърво_измък(A, R, R1).





%%
%% Балансирани дървета
%% 

ребаланс(T,T) :- дърво_балансирано(T).


%%
%% Ротация наляво
%% 
ребаланс(tree(A,T1,T2), tree(B,tree(A,T,L),R)) :- ребаланс(T1,T), ребаланс(T2,tree(B,L,R)),
                                                  дърво_височина(T,N), дърво_височина(L,M), дърво_височина(R,K),
                                                  N #= M,  N + 1 #= K.

%%
%% Ротация надясно
%% 
ребаланс(tree(A,T1,T2), tree(B,L,tree(A,R,T))) :- ребаланс(T1,tree(B,L,R)), ребаланс(T2,T),
                                                  дърво_височина(T,N), дърво_височина(L,M), дърво_височина(R,K),
                                                  N #= K,  N + 1 #= M.
%%
%% Двойна ротация наляво
%% 
ребаланс(tree(A,T1,T2), tree(C, tree(A,T,L1), tree(B,R1,R))) :- ребаланс(T1,T), ребаланс(T2, tree(B,tree(C,L1,R1),R)),
                                                                дърво_височина(T,N), дърво_височина(tree(C,L1,R1),M),
                                                                N + 1 #= M.

%%
%% Двойна ротация надясно
%% 
ребаланс(tree(A,T1,T2), tree(C, tree(B,L,L1), tree(A,R1,T))) :- ребаланс(T1,tree(B,L,tree(C,L1,R1))), ребаланс(T2,T),
                                                                дърво_височина(T,N), дърво_височина(tree(C,L1,R1),M),
                                                                N + 1 #= M.


дърво_балансирано(nil).
дърво_балансирано(tree(_,L,R)) :- дърво_височина(L,N1), дърво_височина(R,N2),
                                  -1 #=< N1 - N2, N1 - N2 #=< 1,
                                  дърво_балансирано(L), дърво_балансирано(R).

дърво_вмък_баланс(A, nil, tree(A,nil,nil)).
дърво_вмък_баланс(A, tree(B,L,R), T) :- A #=< B, дърво_вмък_баланс(A, L, L1), ребаланс(tree(B,L1,R),T).
дърво_вмък_баланс(A, tree(B,L,R), T) :- A #> B, дърво_вмък_баланс(A, R, R1), ребаланс(tree(B,L,R1),T).


дърво_много_вмък_баланс([], T, T).
дърво_много_вмък_баланс([A|Rest], T, T2) :- дърво_много_вмък_баланс(Rest, T, T1), дърво_вмък_баланс(A, T1, T2).


%%
%% Пример:
%% 
%% ?- дърво_много_вмък_баланс([4,3,1,2,6,7,9,5],nil,T).
%% T = tree(5, tree(2, tree(1, nil, nil),
%%                     tree(3, nil, tree(4, nil, nil))),
%%             tree(7, tree(6, nil, nil),
%%                     tree(9, nil, nil))) ;
%% false.
