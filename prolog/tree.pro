?-use_module(library(clpfd)).
%%
%% Кореново двоично дърво
%%
%% T ::= nil | tree(N, T1, T2).
%% 
%%
дърво(nil).
дърво(tree(_,L,R)) :- дърво(L), дърво(R).


%%
%% височина(T,N) - двоичното дърво T има височина N
%% 
%% Условие - известен е скелета на дървото T или височината N
%% 
дърво_височина(nil, 0).
дърво_височина(tree(_,L,R),N) :- N #= max(N1,N2)+1, N #> 0, дърво_височина(L,N1), дърво_височина(R,N2).
%%
%% Защо е важно да имаме условието N #>0 ?
%% Защо е важно ограниченията N #= max(N1,N2)+1, N #> 0 да са в началото, а не в края ?
%%
%% Този предикат може да се използва за генериране на всички дървета с фиксирана височина.
%%
%% ?- дърво_височина(X,2).
%% X = tree(_53904, nil, tree(_55398, nil, nil)) ;
%% X = tree(_53904, tree(_57616, nil, nil), nil) ;
%% X = tree(_53904, tree(_57616, nil, nil), tree(_61112, nil, nil)) ;
%% false.
%%

%%
%% дърво_брой(T,N) - Възлите в двоичното дърво T е N на брой.
%%
%% Условие - известен е скелета на дървото T
%% 
дърво_брой1(nil,0).
дърво_брой1(tree(_,L,R),N) :-дърво_брой1(L,N1), дърво_брой1(R,N2),  N is N1+N2+1, N1 >= 0, N2 >= 0.
%%
%% Този предикат не може да се използва за генериране на всички дървета с определен брой възли.
%%
%% ?- дърво_брой1(T,2).
%% T = tree(_33693442, nil, tree(_33693450, nil, nil)) ;
%% <безкрайно_изчисление>

%%
%% дърво_брой(T,N) - Възлите в двоичното дърво T е N на брой.
%%
%% Условие - известен е скелета на дървото T или броят N
%% 
дърво_брой(nil,0).
дърво_брой(tree(_,L,R),N) :- N #= N1+N2+1, N1 #>= 0, N2 #>= 0, дърво_брой(L,N1), дърво_брой(R,N2).
%%
%% Сега този предикат може да се използва за генериране на всички двоични дървета с фиксиран брой възли.
%% 
%% ?- дърво_брой(X,2).
%% X = tree(_33383224, nil, tree(_33385060, nil, nil)) ;
%% X = tree(_33383224, tree(_33387086, nil, nil), nil) ;
%% false.


%%
%% дърво_вмък1(A, T, T') - подреденото двоично дърво T' се получава от подреденото двоично дърво T като вмъкнем елемента A
%%
%% Условие - елементът A е известен и са известни елементите на T или T'
%% 
дърво_вмък1(A, nil, tree(A,nil,nil)).
дърво_вмък1(A, tree(B,L,R), tree(B,L1,R)) :- дърво_вмък1(A, L, L1), A =< B.
дърво_вмък1(A, tree(B,L,R), tree(B,L,R1)) :- дърво_вмък1(A, R, R1), A > B.


%%
%% дърво_вмък(A, T, T') - подреденото двоично дърво T' се получава от подреденото двоично дърво T като вмъкнем елемента A
%%
%% Условие - ...........
%% 
дърво_вмък(A, nil, tree(A,nil,nil)).
дърво_вмък(A, tree(B,L,R), tree(B,L1,R)) :- A #=< B, дърво_вмък(A, L, L1).
дърво_вмък(A, tree(B,L,R), tree(B,L,R1)) :- A #> B, дърво_вмък(A, R, R1).


%%
%% дърво_много_вмък(L,T,T1) - T1 е двоично подредено дърво, което може да се получи от T, към което се прибавят елемените на списъка L
%%
%% Условие - известни са елементите на списъка L и елементите на T
%% 
дърво_много_вмък([], T, T).
дърво_много_вмък([A|Rest], T, T2) :- дърво_много_вмък(Rest, T, T1), дърво_вмък(A, T1, T2).

конкат([],L,L).
конкат([A|Rest],L,[A|M]) :- конкат(Rest,L,M).

дължина([],0).
дължина([_|Rest], N) :- N #= K+1, K #>= 0, дължина(Rest, K).


%%
%% дърво_списък1(T,L) - L представлява елемените на двоичното дърво T подредени по схемата ляв-корен-дясно
%%
%% Условие - известен е скелета на дървото T
%% 
дърво_списък1(nil,[]).
дърво_списък1(tree(B,L,R), X) :- дърво_списък(L, X1), дърво_списък(R, X2), конкат(X1, [B|X2], X).
%%
%% Можем ли да дефинираме предикат дърво_списък(T,L), който да генерира всички дървета с върхове елементите на L ?
%% За да направим това, трябва да можем да ограничим търсенето на дървета.
%% 
%% равен_брой(T,L) - дървото T и списъка L имат равен брой елементи
%%
%% Условие - известен е скелета на T или на L
%% 
равен_брой(T,L) :- списък_минус_дърво(L,T,[]).
%%
%% списък_минус_дърво(L,T,M) - M = елементите на L, без първите N елемента, където N = брой възли в T.
%% 
списък_минус_дърво(X,nil,X).

списък_минус_дърво([_|X], tree(_,L,R), Y) :-
    списък_минус_дърво(X,L,Z), списък_минус_дърво(Z,R,Y).

%%
%% дърво_списък(T,L) - L представлява елемените на двоичното дърво T подредени по схемата ляв-корен-дясно
%%
%% Условие - известен е скелета на дървото T или на списъка L
%% 
дърво_списък(nil,[]).
дърво_списък(tree(B,L,R), X) :- равен_брой(tree(B,L,R),X), конкат(X1, [B|X2], X), дърво_списък(L, X1), дърво_списък(R, X2).

%%
%% списък_сорт(L,S) - S е пермутацията на L, такава че елемените на S са подредени във възходящ ред
%%
%% Условие - известни са елементите на L
%% 
списък_сорт(L,S) :- дърво_много_вмък(L,nil,T), дърво_списък(T,S).

%%
%% дърво_макс(T,A) - елементът A е най-големият елемент в подреденото дърво T
%%
%% Условие - Известна е структурата на дървото T
%% 
дърво_макс(tree(X,_,nil),X).
дърво_макс(tree(_,_,R),Y) :- дърво_макс(R,Y).

%%
%% дърво_мин(T,A) - елементът A е най-малкият елемент в подреденото дърво T
%%
%% Условие - Известна е структурата на дървото T
%% 
дърво_мин(tree(X,nil,_),X).
дърво_мин(tree(_,L,_),Y) :- дърво_мин(L,Y).

%%
%% дърво_елем(T,E) - елементът E е връх в подреденото дърво T
%%
%% Условие - скелетът на дървото T
%% 
дърво_елем(tree(A,_,_),A).
дърво_елем(tree(A,L,_),B) :- B #< A, дърво_елем(L,B).
дърво_елем(tree(A,_,R),B) :- A #< B, дърво_елем(R,B).
%%
%% Пример:
%%
%% ?- дърво_брой(T,2), дърво_елем(T,1), дърво_елем(T,2).
%% T = tree(1, nil, tree(2, nil, nil)) ;
%% T = tree(2, tree(1, nil, nil), nil) ;
%% false.


%%
%% дърво_подредено(T) - T е дърво с подредба да елементите ляв-корен-десен
%% 
%% Условие - известни са елемените на T
%% 
дърво_подредено(nil).
дърво_подредено(tree(X,L,R)) :- дърво_макс(L,Y), дърво_мин(R,Z), Y =< X, X =< Z.


списък_измък(A,[A|Rest], Rest).
списък_измък(A, [B|Rest], [A|L]) :- A #\= B, списък_измък(A, Rest, L).


дърво_измък2(A, T1, T2) :- дърво_списък(T1, L1), списък_измък(A, L1, L2), дърво_много_вмък(L2, nil, T2).

%%
%% дърво_измък1(A, T1, T2) - дървото T2 е получено от подреденото двоично дърво T1 
%% 
дърво_измък1(A, tree(A,L,nil),L).
дърво_измък1(A, tree(A,nil,R),R).
дърво_измък1(A, tree(A,tree(B,L1,R1), R), tree(B,L1,R2)) :- дърво_списък(R1,S), дърво_много_вмък(S,R,R2).
дърво_измък1(A, tree(B,L,R), tree(B,L1,R)) :- A =< B, дърво_измък1(A, L, L1).
дърво_измък1(A, tree(B,L,R), tree(B,L,R1)) :- B < A, дърво_измък1(A, R, R1).


%%
%% Балансирано дърво - двоично подредено дърво, в което разликата във височините на лявото и дясното поддърво е не повече от единица
%% 

%%
%% ребаланс(T1,T2) - T2 е балансирано дърво и съдържа точно елементите на T1.
%% 
ребаланс(T,T) :- дърво_балансирано(T).


%%
%% Ротация наляво
%% 
ребаланс(tree(A,T1,T2), tree(B,tree(A,T,L),R)) :- ребаланс(T1,T), ребаланс(T2,tree(B,L,R)),
                                                  дърво_височина(T,N), дърво_височина(L,M), дърво_височина(R,K),
                                                  N #= M,  N + 1 #= K.

%%
%% Ротация надясно
%% 
ребаланс(tree(A,T1,T2), tree(B,L,tree(A,R,T))) :- ребаланс(T1,tree(B,L,R)), ребаланс(T2,T),
                                                  дърво_височина(T,N), дърво_височина(L,M), дърво_височина(R,K),
                                                  N #= K,  N + 1 #= M.
%%
%% Двойна ротация наляво
%% 
ребаланс(tree(A,T1,T2), tree(C, tree(A,T,L1), tree(B,R1,R))) :- ребаланс(T1,T), ребаланс(T2, tree(B,tree(C,L1,R1),R)),
                                                                дърво_височина(T,N), дърво_височина(tree(C,L1,R1),M),
                                                                N + 1 #= M.

%%
%% Двойна ротация надясно
%% 
ребаланс(tree(A,T1,T2), tree(C, tree(B,L,L1), tree(A,R1,T))) :- ребаланс(T1,tree(B,L,tree(C,L1,R1))), ребаланс(T2,T),
                                                                дърво_височина(T,N), дърво_височина(tree(C,L1,R1),M),
                                                                N + 1 #= M.

дърво_балансирано(nil).
дърво_балансирано(tree(_,L,R)) :- дърво_височина(L,N1), дърво_височина(R,N2),
                                  -1 #=< N1 - N2, N1 - N2 #=< 1,
                                  дърво_балансирано(L), дърво_балансирано(R).

дърво_вмък_баланс(A, nil, tree(A,nil,nil)).
дърво_вмък_баланс(A, tree(B,L,R), T) :- A #=< B, дърво_вмък_баланс(A, L, L1), ребаланс(tree(B,L1,R),T).
дърво_вмък_баланс(A, tree(B,L,R), T) :- A #> B, дърво_вмък_баланс(A, R, R1), ребаланс(tree(B,L,R1),T).


дърво_много_вмък_баланс1(L, T, T2) :- дърво_много_вмък(L,T,T1), ребаланс(T1,T2).

дърво_много_вмък_баланс([], T, T).
дърво_много_вмък_баланс([A|Rest], T, T2) :- дърво_много_вмък_баланс(Rest, T, T1), дърво_вмък_баланс(A, T1, T2).



%%
%% Пример:
%% 
%% ?- дърво_много_вмък_баланс([4,3,1,2,6,7,9,5],nil,T).
%% T = tree(5, tree(2, tree(1, nil, nil),
%%                     tree(3, nil, tree(4, nil, nil))),
%%             tree(7, tree(6, nil, nil),
%%                     tree(9, nil, nil))) ;
%% false.
%%
%% ?- дърво_много_вмък_баланс(L,nil,tree(2,tree(1,nil,nil),tree(3,nil,nil))).
%% L = [1, 2, 3] ;
%% L = [2, 1, 3] ;
%% L = [3, 1, 2] ;
%% L = [1, 3, 2] ;
%% L = [2, 3, 1] ;
%% L = [3, 2, 1] ;
%% <безкрайно_изчисление>



списък_дърво_баланс1([], nil).
списък_дърво_баланс1(L, T) :- равен_брой(T,L), дърво_балансирано(T), дърво_много_вмък_баланс(L,nil,T).



