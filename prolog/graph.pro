%% 
%% Целият свят, за който знае пролог, е един краен граф описан със следните факти:
%% 

връх(g1,a). връх(g1,b). връх(g1,c). връх(g1,d). връх(g1,e).
връх(g1,f). връх(g1,g). връх(g1,e). връх(g1,u).

връх(g2,a). връх(g2,b). връх(g2,c). връх(g2,d). връх(g2,e). връх(g2,f).

ребро(g1,a,b). ребро(g1,b,c). ребро(g1,c,d). ребро(g1,d,b).
ребро(g1,a,e). ребро(g1,e,f). ребро(g1,f,g). ребро(g1,g,e).
ребро(g1,u,c).


%%
%% Нека имаме и още един граф, в който няма цикли
%% 



ребро(g2,a,b). ребро(g2,b,c). ребро(g2,c,d). ребро(g2,e,b). ребро(g2, f, a).



%%
%% Да видим сега как можем да определим дали имаме път между два върха в този граф.
%% 

път(G,X,X) :- връх(G,X).
път(G,X,Y) :- ребро(G,X,Z), път(G,Z,Y).


%% В g2 е лесно, защото няма цикли:
%% ?- път(g2, a, f).
%% false
%% ?- път(g2, a, d).
%% true;
%% false.

%% В g1 имаме проблем, защото имаме цикли:
%% ?- път(g1, a, d).
%% true;
%% true;
%% true;
%% ...
%% Това е още по-неприятно:
%% ?- път(g1, a, u).
%% <безкраен_цикъл>
%%
%% Можем да се спасим от тази ситуация, ако декларираме, че предикатът път е табличен:
%% ?- table път(+,+,+).
%% 

прост_път(G,X,Y) :- път_забрана(G,X,Y,[]).

път_забрана(G,X,X,V) :-
    връх(G,X), не_вътре(X,V).

път_забрана(G,X,Y,V) :-
    не_вътре(X,V), ребро(G,X,Z), път_забрана(G,Z,Y,[X|V]).


не_вътре(_,[]).
не_вътре(X, [Y|Rest]) :- dif(X,Y), не_вътре(X,Rest).



%%
%% Каква е разликата между предикатите път(g2,a,X) и отново_път(g2,a,X) ?
%%
%%:- table отново_път(+,+,+).
отново_път(G,X,X) :- връх(G,X).
отново_път(G,X,Y) :- отново_път(G,X,Z), ребро(G,Z,Y).


има_път(G,X,X,[X]) :- връх(G,X).
има_път(G,X,Y,[X|Rest]) :- ребро(G,X,Z), има_път(G,Z,Y,Rest).

%%
%% ?- има_път(g1,a,u,X).
%% <безкраен_цикъл>



%%
%% Конюнкцията не е напълно комутативна. Няма как пролог да даде грешен отговор, но редът на атомите
%% в една конюнкция е важен за бързодействието на търсенето на отговор
%% 

path1(G,X,Y) :- ребро(G,X,Y).
path1(G,X,Y) :- path1(G,X,Z), ребро(G,Z,Y).

path2(G,X,Y) :- ребро(G,X,Y).
path2(G,X,Y) :- ребро(G,Z,Y), path2(G,X,Z).

%% is_path(X,Y,[X,Y]) :- ребро(X,Y).
%% is_path(X,Y,[X|Rest]) :- ребро(X,Z), is_path(Z,Y,Rest).


%% member1(X, [X|_]).
%% member1(X, [_|Rest]) :- member1(X,Rest).

%% not_member(X,[]).
%% not_member(X,[Y|Rest]) :- X

%%
%% Прост път - път без повтарящи се ребра
%%
%% is_simple_path(X,Y,[X,Y]) :- edge(X,Y).
%% is_simple_path(X,Y,[X|Rest]) :- (\+ member1(X,Rest)), edge(X,Z), is_simple_path(Z,Y,Rest).
