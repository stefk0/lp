?- use_module(library(clpfd)).


%%
%% Тук важното е, че за да се прави сравнение от вида A #=< B не е нужда да се знаят стойностите и на двете променливи.
%% Ако използваме A =< B, то трябва да знаем стойностите на A и B.
%% 

%%
%% пръв(A,L) :- конкат([A],_,L).
%%
пръв(A,L) :- L = [A|_].

%
%втори(A,L) :- конкат([_,A],_,L).
%
втори(A,L) :- L = [_,A|_].

трети(A,L) :- L = [_,_,A|_].

%% Намиране на последния елемент A на списъка L
%% последен(A,L).
%%
%% Условие - дължината на L е известна

последен(A,[A]).
последен(A,[_|Rest]) :- последен(A,Rest).

%% Възможно е да не знаем конкретните стойности на елементите на L
%% 
%% ?- последен(A,[X,Y,Z]).
%% A = Z ;
%% false.
%% 

предпоследен(A,[A,_]).
предпоследен(A,[_|Rest]) :- предпоследен(A,Rest).

%%
%% сортиран(X) - списъкът X е подреден във възходящ ред
%% 
%% Условие - дължината на X е известна
%%
подреден([]).
подреден([_]).
подреден([A,B|Rest]) :- A #=< B, подреден([B|Rest]).


%%
%% конкат(L1,L2,M) - М конкатенацията на списъците L1 и L2, т.е. M = L1.L2
%%
%% Условие - дължината на L1 или дължината на M е известна
%%
конкат([],L,L).
конкат([A|Rest],L,[A|M]) :- конкат(Rest,L,M).


предпоследен2(A,L) :- конкат(_,[A,_],L).

%%
%% обрат(X,Y) - Y представлява списък с елементите на X в обратен ред.
%%
%% Условие - известна е дължината на X
%% 
бавен_обрат([],[]).
бавен_обрат([A|X], Y) :- бавен_обрат(X,Z), конкат(Z,[A],Y).
%%
%% ?- обрат(X,[1,2,3]).
%% X = [3, 2, 1] ;
%% <безкрайно изчисление>  
%%

%%
%% равна_дължина(X,Y) - списъците X и Y имат равни дължини.
%%
%% Условие - известна е дължината на X или Y.
%% 
равна_дължина([],[]).
равна_дължина([_|Rest],[_|Tail]) :- равна_дължина(Rest,Tail).
%% 
%% ?- равна_дължина([A,B,C],[X,Y,Z]).
%% true.
%% 

дължина([],0).
дължина([_|Rest], N) :- N #= K+1, K #>= 0, дължина(Rest, K).


%%
%% хубав_обрат(X,Y) - Y представлява спъсък с елементите на X в обратен ред
%% Условие - известна е дължината на X или Y.
%% 
хубав_обрат([],[]).
хубав_обрат(X,Y) :- равна_дължина(X,Y), бавен_обрат(X,Y).
%% 
%% ?- хубав_обрат([A,B,C],[X,Y,Z]).
%% A = Z,
%% B = Y,
%% C = X.
%%
%% Това вече работи:
%% ?- хубав_обрат(X,[1,2,3]).
%% X = [3, 2, 1].                 
%%
%% Естествено, тази версия си остава доста неефективна.

бърз_обрат(L,R) :- равна_дължина(L,R), линеен_обрат(L,[],R).

%%
%% линеен_обрат(L,S,R) - R = rev(L) . S
%%
линеен_обрат([],S,S).
%% R = rev([A|L]) . S = rev(L) . [A|S]
линеен_обрат([A|L],S,R) :- линеен_обрат(L, [A|S], R).


палиндром(X) :- бърз_обрат(X,X).


%% 
%% елем(A,L) - A е елемент на L
%%
%% Условие - дължината на L е известна
%% 
елем(A,[A|_]).
елем(A,[_|Rest]) :- елем(A,Rest).

%% 
%% ?- елем(f(X),[1,2,f(a),g(c),C]).
%% X = a ;
%% C = f(X) ;
%% false.
%% 

%% 
%% Алтернативна дефиниция
%% 
елем2(A,L) :- конкат(_, [A|_], L).

%% 
%% подсписък(L,M) - L е подсписък на M, т.е. M = X.L.Y
%%
%% Условие - дължината на M е известна
%% 
подсписък(L,M) :- конкат(L1,_,M), конкат(_,L,L1).
%% 
%% ?- подсписък([A,f(A)],[f(a),X,f(f(b))]).
%% A = f(a),
%% X = f(f(a)) ;
%% A = X, X = f(b) ;
%% false.
%% 

%%
%% Какъв е проблемът с тази дефиниция?
%%
лош_подсписък(L,M) :- конкат(_,L,L1), конкат(L1,_,M).
%%
%% В конкат(_,L,L1) трябва да знаем дължината или на първия или на третия аргумент,
%% но ние не знаем нищо подобно. 
%% 

%% 
%% подмножество(X,Y) - 
%% X е подмножество на Y точно тогава, когато (forall a)[a in X -> a \in Y]
%% Условие - дължината на X и Y е известна
%% 
подмножество([],_).
подмножество([A|Rest], Y) :- елем(A,Y), подмножество(Rest,Y).


%%
%% Не е добре да се ползва not
%%  
подмножество2(X,Y) :- not((елем(A,X), not(елем(A,Y)))). 



%%
%% вмък(A,X,Y) - Y се получава от X като вмъкнем A на произволно място в X
%%
%% Условие - дължината на X или Y е известна
%% 
вмък(A,X,[A|X]).
вмък(A,[B|X],[B|Y]) :- вмък(A,X,Y).


%% 
%% разбърк(X,Y) - Y е пермутация на X
%%
%% Условие - дължината на X е известна 
%% 
разбърк([],[]).
разбърк([A|X],Y) :- разбърк(X,Z), вмък(A,Z,Y).

%% 
%% пермутация2(X,Y) - Y е пермутация на X
%%
%% Условие - дължината на Y е известна
%% 
разбърк2([],[]).
разбърк2([A|X],Y) :- вмък(A,Z,Y), разбърк2(X,Z).

%% 
%% сортиране(X,Y) - Y е сортирана пермутация на X
%%
%% Условие - дължината на X или Y е известна
%% 
сортиране(X,Y) :- равна_дължина(X,Y), разбърк(X,Y), подреден(Y).
%
%% ?- сортиране(X,[1,2,3]).
%% X = [1, 2, 3] ;
%% X = [2, 1, 3] ;
%% X = [3, 1, 2] ;
%% X = [1, 3, 2] ;
%% X = [2, 3, 1] ;
%% X = [3, 2, 1] ;
%% false.

%%
%% минизмък(A,X,Y) - Y се получава от X като измъкнем най-малкия елемент А от X
%%
%% Условие - известни са елементите на X или е известен елементът A и елементите на Y
%% 
минизмък(A,[A],[]).
минизмък(A,[A|X],X) :- минизмък(B,X,_), A =< B.
минизмък(A,[B|X],[B|Y]) :- минизмък(A,X,Y), A =< B, елем(A,X).
%%
%% Тук сравненията A =< B трябва да са след минизмък, защото променливите A и B трябва да имат стойност.
%%

%% 
%% сортизмък(X,Y) - списъкът Y е резултатът от сортирането на X
%%
%% Условие - известни са елементите на X
%% 
сортизмък([],[]).
сортизмък(X, [A|Y]) :- минизмък(A,X,Rest), сортизмък(Rest, Y).


%%
%% сортвмък(A,X,Y) - Вмъкваме A в сортирания списък X, така че да получим сортиран списък Y
%% 
%% Условие - известен е елементът A и са известни елементите на X или Y.
%% 
сортвмък(A,[],[A]).
сортвмък(A,[B|X],[A,B|X]) :- A #=< B.
сортвмък(A,[B|X],[B|Y]) :- B #< A, сортвмък(A,X,Y).


%%
%% минмакс(A,B,C,D) - C = min(A,B) & D = max(A,B)
%%
%% Условие - числата A и B са известни
минмакс(A,B,A,B) :- A #=< B.
минмакс(A,B,B,A) :- B #< A.

%%
%% Втори вариант
%%
%% сортвмък2(A,X,Y) - Вмъкваме A в сортирания списък X, така че да получим сортиран списък Y
%%
%% Условие - Известен е елементът A и елементите на X (тук имаме разлика с първата версия)
%% 
сортвмък2(A,[],[A]).
сортвмък2(A, [B|X], [C|Y]) :- минмакс(A,B,C,D), сортвмък2(D,X,Y).

%%
%% сорт3(X,Y) - Y е сортирана пермутация на X
%%
%% Условие - известни са елементите на списъка X
%% 
сорт3([],[]).
сорт3([A|Rest], Y) :- сорт3(Rest,X), сортвмък(A,X,Y).



раздел([],_,[],[]).
раздел([B|Rest],A,[B|L1],L2) :- B #=< A, раздел(Rest, A, L1, L2).
раздел([B|Rest],A,L1,[B|L2]) :- A #< B, раздел(Rest, A, L1, L2).

бърз_сорт([],[]).
бърз_сорт([A|Rest], S) :- равна_дължина([A|Rest],S), раздел(Rest, A, L1, L2), бърз_сорт(L1,S1), бърз_сорт(L2,S2), конкат(S1, [A|S2], S).
